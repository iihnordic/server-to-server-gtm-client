___TERMS_OF_SERVICE___

By creating or modifying this file you agree to Google Tag Manager's Community
Template Gallery Developer Terms of Service available at
https://developers.google.com/tag-manager/gallery-tos (or such other URL as
Google may provide), as modified from time to time.


___INFO___

{
  "type": "CLIENT",
  "id": "cvt_temp_public_id",
  "version": 1,
  "securityGroups": [],
  "displayName": "Server-to-Server",
  "categories": [
    "UTILITY"
  ],
  "brand": {
    "id": "brand_dummy",
    "displayName": "Square",
    "thumbnail": "data:image/png;base64,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\u003d"
  },
  "description": "This client accepts HTTP POST requests and parses the event body into events. Useful when sending data to sGTM from another server such as your customer data platform.",
  "containerContexts": [
    "SERVER"
  ]
}


___TEMPLATE_PARAMETERS___

[
  {
    "type": "GROUP",
    "name": "Authorization",
    "displayName": "Authorization",
    "groupStyle": "ZIPPY_OPEN",
    "subParams": [
      {
        "type": "CHECKBOX",
        "name": "useBearerToken",
        "checkboxText": "Require authorized requests in production",
        "simpleValueType": true,
        "subParams": [
          {
            "type": "TEXT",
            "name": "bearerToken",
            "displayName": "Bearer Token",
            "simpleValueType": true,
            "help": "The authorization credentials sent by your server must match the string entered here.",
            "valueValidators": [
              {
                "type": "NON_EMPTY"
              }
            ],
            "enablingConditions": [
              {
                "paramName": "useBearerToken",
                "paramValue": true,
                "type": "EQUALS"
              }
            ]
          }
        ],
        "help": "Checking this box will require your server to send post requests with an authorization header.",
        "alwaysInSummary": true
      },
      {
        "type": "CHECKBOX",
        "name": "usePreviewBearerToken",
        "checkboxText": "Require authorized requests in preview mode",
        "simpleValueType": true,
        "help": "Checking this box will require users to send post requests with an authorization header when in preview mode.",
        "subParams": [
          {
            "type": "TEXT",
            "name": "previewBearerToken",
            "displayName": "Preview Bearer Token",
            "simpleValueType": true,
            "enablingConditions": [
              {
                "paramName": "usePreviewBearerToken",
                "paramValue": true,
                "type": "EQUALS"
              }
            ],
            "help": "The authorization credentials included in preview requests must match the string entered here.",
            "valueValidators": [
              {
                "type": "NON_EMPTY"
              }
            ]
          }
        ],
        "enablingConditions": [
          {
            "paramName": "useBearerToken",
            "paramValue": true,
            "type": "EQUALS"
          }
        ]
      },
      {
        "type": "CHECKBOX",
        "name": "rejectUnauthorized",
        "checkboxText": "Reject unauthorized requests",
        "simpleValueType": true,
        "enablingConditions": [
          {
            "paramName": "useBearerToken",
            "paramValue": true,
            "type": "EQUALS"
          }
        ],
        "help": "If an authorization header is included but does not match the token, check this box to claim the request and respond with a 401 error. If you leave this box unchecked, this client will not claim the request and the request will be evaluated by the next client."
      }
    ]
  },
  {
    "type": "GROUP",
    "name": "Type Checking",
    "displayName": "Type Checking",
    "groupStyle": "ZIPPY_OPEN",
    "subParams": [
      {
        "type": "SIMPLE_TABLE",
        "name": "primitiveTypes",
        "displayName": "Primitive Types",
        "simpleTableColumns": [
          {
            "defaultValue": "",
            "displayName": "Field Name",
            "name": "field",
            "type": "TEXT"
          },
          {
            "defaultValue": "",
            "displayName": "Type",
            "name": "type",
            "type": "SELECT",
            "selectItems": [
              {
                "value": "string",
                "displayValue": "string"
              },
              {
                "value": "number",
                "displayValue": "number"
              },
              {
                "value": "boolean",
                "displayValue": "boolean"
              }
            ]
          },
          {
            "defaultValue": "",
            "displayName": "Required",
            "name": "required",
            "type": "SELECT",
            "selectItems": [
              {
                "value": true,
                "displayValue": "true"
              },
              {
                "value": false,
                "displayValue": "false"
              }
            ]
          }
        ],
        "help": "Add primitive typed event fields (numbers, strings, booleans) to ensure they correctly type checked. To override the type or required status of existing fields, reenter them here."
      },
      {
        "type": "TEXT",
        "name": "structuralTypes",
        "displayName": "Structural Types",
        "simpleValueType": true,
        "lineCount": 10,
        "valueValidators": [],
        "help": "Enter JSON for type checking complex structures (arrays and objects). See the documentation for more instructions."
      }
    ],
    "help": "Add additional type checking to your client. The client will not process any events with incorrectly typed fields or required events that are missing. Server-Side Google Tag Manager Common Event Data is already included in type checking. From this list, \"event_name\" is required but all other fields are optional."
  }
]


___SANDBOXED_JS_FOR_SERVER___

/*
Copyright 2021 Square Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* eslint-disable eslint-comments/disable-enable-pair */
/* eslint-disable prefer-template */
/* eslint-disable object-shorthand */
/* global data */


const JSON = require('JSON');
const runContainer = require('runContainer');
const claimRequest = require('claimRequest');
const returnResponse = require('returnResponse');
const logToConsole = require('logToConsole');
const getRequestBody = require('getRequestBody');
const getRequestHeader = require('getRequestHeader');
const getContainerVersion = require('getContainerVersion');
const addEventCallback = require('addEventCallback');
const setResponseBody = require('setResponseBody');
const setResponseStatus = require('setResponseStatus');

const containerVersion = getContainerVersion();
const previewMode = containerVersion.previewMode;
const containerId = containerVersion.containerId;

const auth = getRequestHeader('Authorization');
const prodAuthCondition = !data.useBearerToken || auth === 'Bearer ' + data.bearerToken;
const previewAuthCondition = !data.usePreviewBearerToken || auth === 'Bearer ' + data.previewBearerToken;

let numSchemaErr = 0;
const invalidSchemaEvents = [];
const fullyFailedTagEvents = [];
const partialFailedTagEvents = [];
const failedTags = [];

/** **** Code execution starts here ******/

// IIFE to take advantage of return statement to end execution
(function runClient(){

  const validAuth = prodAuthCondition || (previewAuthCondition && previewMode);

  if (!validAuth) {

    if (data.rejectUnauthorized && typeof auth === 'string') {
      claimRequest();
      const error = formatAndLogErrorMessage('ERR_AUTH');
      respond(401, error);
    }

    return;
  }

  claimRequest();

  const bodyStr = getRequestBody();
  if (!bodyStr) {
    const error = formatAndLogErrorMessage('ERR_BODY_NO_JSON');
    respond(400, error);
    return;
  }

  const events = JSON.parse(bodyStr);
  if (!events || !isArray(events)) {
    const error = formatAndLogErrorMessage('ERR_BODY_ARR', { actualType: typeof events });
    respond(422, error);
    return;
  }

  // edge case for if events in payload are empty
  // unlikely to occur, but this is considered a success
  if (events.length === 0) {
    respond(200);
    return;
  }

  processEvents(
    events,
    function finishProcessing(
      totalTags,
      tagSuccess,
      tagFailure,
      eventSchemaSuccess,
      eventSchemaFailure
    ) {
      if (tagFailure === 0 && eventSchemaFailure === 0) {
        respond(200);
        return;
      }

      if (eventSchemaSuccess === 0) {
        const error = formatAndLogErrorMessage('ERR_EVENT_SCHEMA');
        respond(422, error);
        return;
      }

      if (tagSuccess === 0 && totalTags > 0) {
        const error = formatAndLogErrorMessage('ERR_TAG', { numTriggered: totalTags, failedTags: failedTags });
        respond(500, error);
        return;
      }

      const error = formatAndLogErrorMessage(
        'ERR_PARTIAL_CONTENT',
        {
          totalTags: totalTags,
          tagSuccess: tagSuccess,
          tagFailure: tagFailure,
          failedTags: failedTags,
          eventSchemaSuccess: eventSchemaSuccess,
          eventSchemaFailure: eventSchemaFailure,
        }
      );
      respond(206, error);
    }
  );
})();


/** ********* Helper methods  ***********/

function respond(statusCode, errorMessage) {
  const body = JSON.stringify({
    status: statusCode,
    error: errorMessage || '',
    invalidSchemaEvents: invalidSchemaEvents,
    fullyFailedTagEvents: fullyFailedTagEvents,
    partialFailedTagEvents: partialFailedTagEvents,
    failedTags: failedTags,
  });

  setResponseStatus(statusCode);
  setResponseBody(body);
  returnResponse();
}

// Async process method
function processEvents(events, finishProcessing) {
  const numEvents = events.length;
  let eventsCompleted = 0;
  let countTagSuccess = 0;
  let countTagFailure = 0;
  let countTotalTags = 0;
  let countEventSchemaSuccess = 0;
  let countEventSchemaFailure = 0;

  events.forEach((event, eventIndex) => {
    if (eventMatchesSchema(event, eventIndex)) {
      countEventSchemaSuccess++;
    } else {
      countEventSchemaFailure++;
      invalidSchemaEvents.push(eventIndex);

      eventsCompleted++;
      if (numEvents === eventsCompleted) {
        finishProcessing(
          countTotalTags,
          countTagSuccess,
          countTagFailure,
          countEventSchemaSuccess,
          countEventSchemaFailure
        );
      }

      return;
    }

    runContainer(event, /* onComplete= */ (bindToEvent) => {
      bindToEvent(addEventCallback)((containerId, eventData) => {
        let tagFailForEvent = 0;

        eventData.tags.forEach(tag => {
          countTotalTags++;
          if (tag.status === 'success') {
            countTagSuccess++;
          } else if (tag.status === 'failure') {
            failedTags.push({
              tagInfo: tag,
              eventIndex: eventIndex,
            });
            countTagFailure++;
            tagFailForEvent++;
          }
        });

        if (eventData.tags.length > 0) {
          // if tags fail, put event in the appropriate bucket
          if (tagFailForEvent === eventData.tags.length) {
            fullyFailedTagEvents.push(eventIndex);
            logToConsole('All ' + tagFailForEvent + ' tags failed for the ' + event.event_name + ' event');
          } else if (tagFailForEvent > 0) {
            partialFailedTagEvents.push(eventIndex);
            logToConsole(tagFailForEvent + ' / ' + eventData.tags.length + ' tags failed for the "' + event.event_name + '" event');
          }
        }

        eventsCompleted++;
        logPreview('"' + event.event_name + '" event successfully processed');
        logPreview(eventsCompleted + ' / ' + numEvents + ' events processed');

        if (numEvents === eventsCompleted) {
          finishProcessing(
            countTotalTags,
            countTagSuccess,
            countTagFailure,
            countEventSchemaSuccess,
            countEventSchemaFailure
          );
        }
      });
    });
  });
}


/** ******* Schema Definition *********/

function eventMatchesSchema(value, eventIndex) {
  const eventSchema = {
    type: 'object',
    required: 'true',
    value: {
      client_id: { type: 'string', required: false },
      event_name: { type: 'string', required: true },
      ip_override: { type: 'string', required: false },
      language: { type: 'string', required: false },
      page_encoding: { type: 'string', required: false },
      page_hostname: { type: 'string', required: false },
      page_location: { type: 'string', required: false },
      page_path: { type: 'string', required: false },
      page_referrer: { type: 'string', required: false },
      page_title: { type: 'string', required: false },
      screen_resolution: { type: 'string', required: false },
      user_agent: { type: 'string', required: false },
      user_data: {
        type: 'object',
        required: false,
        value: {
          email_address: { type: 'string', required: false },
          phone_number: { type: 'string', required: false },
          first_name: { type: 'string', required: false },
          last_name: { type: 'string', required: false },
          street: { type: 'string', required: false },
          city: { type: 'string', required: false },
          region: { type: 'string', required: false },
          postal_code: { type: 'string', required: false },
          country: { type: 'string', required: false },
        }
      },
      user_id: { type: 'string', required: false },
      viewport_size: { type: 'string', required: false },
    }
  };

  if (isArray(data.primitiveTypes)) {
    data.primitiveTypes.forEach(field => {
      eventSchema.value[field.field] = { type: field.type, required: field.required };
    });
  }

  if (data.structuralTypes) {
    const fields = JSON.parse(data.structuralTypes);
    if (fields) {
      for (const key in fields) {
        eventSchema.value[key] = fields[key];
      }
    }
  }

  return validate(value, eventSchema, 'events[' + eventIndex + ']');
}


/** ****** Schematizing methods  *******/

function validate(inputVal, schema, path) {
  const expectedType = schema.type;
  const required = schema.required;
  const schemaVal = schema.value;

  const actualType = typeof inputVal;

  if (isNullOrUndef(inputVal)) {
    if (required) {
      formatAndLogErrorMessage('ERR_MISSING', { value: inputVal, name: path });
      return false;
    } else {
      return true;
    }
  }

  if (isArray(inputVal) && expectedType === 'array') {
    const results = inputVal.map((ele, i) => {
      return validate(ele, schemaVal, path + '[' + i + ']');
    });
    return allValid(results);
  }

  if (actualType !== expectedType) {
    formatAndLogErrorMessage('ERR_SCHEMA', {
      value: inputVal,
      expectedType: expectedType,
      actualType: isArray(inputVal) ? 'array' : actualType,
      name: path,
      required: required
    });
    return false;
  }

  if (expectedType === 'object') {
    const results = [];
    for (const keyName in schemaVal) {
      results.push(validate(inputVal[keyName], schemaVal[keyName], path + '.' + keyName));
    }
    return allValid(results);
  }

  return true;
}

function allValid(arr) {
  return arr.reduce((acc, val) => acc && val, true);
}

function isNullOrUndef(value) {
  return value === undefined || value === null;
}

// built in Array.isArray method is not available in Sandboxed JS
function isArray(value) {
  return typeof value === 'object' && typeof value.length === 'number';
}


/** ********* Error handling and logging ***********/

function formatAndLogErrorMessage(errorCode, errorData) {
  const errorMessage = generateErrorMessage(errorCode, errorData);
  const fullErrorMessage = '[' + containerId + '][Server-to-Server Client][Error] - ' + errorMessage;
  logToConsole(fullErrorMessage);
  return fullErrorMessage;
}

function generateErrorMessage(name, errData) {
  const complexErrors = {
    ERR_TAG: formatTagError,
    ERR_SCHEMA: formatSchemaError,
    ERR_MISSING: formatMissingError,
    ERR_BODY_ARR: formatBodyError,
    ERR_PARTIAL_CONTENT: formatPartialContentError
  };

  if (complexErrors[name]) {
    return complexErrors[name](errData);
  }

  const simpleErrors = {
    ERR_AUTH: 'Authorization: The authorization is invalid. Ensure you are including the correct authorization header in your request.',
    ERR_BODY_NO_JSON: 'Body: The request body is missing. Verify your request body is valid JSON.',
    ERR_EVENT_SCHEMA: 'Events: No events in the request body fit the schema. Verify your request matches the common event data schema https://developers.google.com/tag-manager/serverside/common-event-data or the type checking schema you defined in the client configuration.'
  };

  if (!simpleErrors[name]) {
    return 'Error message is unspecified';
  }

  return simpleErrors[name];
}

function formatPartialContentError(errData) {
  return 'Partial Success: At least one event had the correct schema and at least one tag executed successfully. ' +
  'However, some failed:\n' +
  errData.eventSchemaSuccess + ' tag' + formatPlural(errData.eventSchemaSuccess) + 'matched the event schema.\n' +
  errData.eventSchemaFailure + ' tag' + formatPlural(errData.eventSchemaFailure) + 'did not match the event schema.\n' +
  errData.totalTags + ' tag' + formatPlural(errData.totalTags) + (errData.totalTags === 1 ? 'was ' : 'were ') + 'triggered in total.\n' +
  errData.tagSuccess + ' tag' + formatPlural(errData.tagSuccess) + 'succeeded in sending.\n' +
  errData.tagFailure + ' tag' + formatPlural(errData.tagFailure) + 'failed in sending.\n' +
  'Verify your request matches the common event data schema https://developers.google.com/tag-manager/serverside/common-event-data or the type checking schema you defined in the client configuration.\nFailed Tags Info: ' +
  JSON.stringify(errData.failedTags);
}

function formatTagError(errData) {
  return 'Tags: ' + errData.numTriggered + ' tag' + formatPlural(errData.numTriggered) +
  (errData.numTriggered === 1 ? 'was ' : 'were ') + 'triggered. ' +
  '0 tags succeeded. Check the logic in your tags to determine why they failed.\nFailed Tags Info: ' + JSON.stringify(errData.failedTags);
}

function formatBodyError(errData) {
  numSchemaErr++;

  return 'Body: The request body is not of type array. ' +
  'Instead received a type of "' + errData.actualType + '" ' +
  'The JSON may be invalid. The sGTM client expects an array of event objects.\n' +
  'Type error #' + numSchemaErr;
}

function formatSchemaError(errData) {
  numSchemaErr++;

  return 'Schema: The "' + errData.name + '" field was not of expected type "' + errData.expectedType + '". ' +
  'Instead received the value type "' + errData.actualType + '". ' +
  'This field is' + (errData.required ? ' ' : ' not ') + 'required.\n' +
  'The following value was received: ' + JSON.stringify(errData.value) + '\n' +
  'Type error #' + numSchemaErr;
}

function formatMissingError(errData) {
  numSchemaErr++;

  return 'Missing Field: The "' + errData.name + '" value is required but was not found. ' +
  'Instead received a value of "' + errData.value + '"\n Type error #' + numSchemaErr;
}

function formatPlural(num) {
  return num === 1 ? ' ' : 's ';
}

function logPreview(log) {
  if (previewMode) {
    logToConsole('[' + containerId + '][Server-to-Server Client][Info] - ' + log);
  }
}



___SERVER_PERMISSIONS___

[
  {
    "instance": {
      "key": {
        "publicId": "read_event_metadata",
        "versionId": "1"
      },
      "param": []
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "read_request",
        "versionId": "1"
      },
      "param": [
        {
          "key": "headerWhitelist",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "headerName"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "Authorization"
                  }
                ]
              }
            ]
          }
        },
        {
          "key": "bodyAllowed",
          "value": {
            "type": 8,
            "boolean": true
          }
        },
        {
          "key": "headersAllowed",
          "value": {
            "type": 8,
            "boolean": true
          }
        },
        {
          "key": "requestAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "headerAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "queryParameterAccess",
          "value": {
            "type": 1,
            "string": "any"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "return_response",
        "versionId": "1"
      },
      "param": []
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "logging",
        "versionId": "1"
      },
      "param": [
        {
          "key": "environments",
          "value": {
            "type": 1,
            "string": "all"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "read_container_data",
        "versionId": "1"
      },
      "param": []
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "access_response",
        "versionId": "1"
      },
      "param": [
        {
          "key": "writeResponseAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "writeStatusAllowed",
          "value": {
            "type": 8,
            "boolean": true
          }
        },
        {
          "key": "writeBodyAllowed",
          "value": {
            "type": 8,
            "boolean": true
          }
        },
        {
          "key": "writeHeaderAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "run_container",
        "versionId": "1"
      },
      "param": []
    },
    "isRequired": true
  }
]


___TESTS___

scenarios:
- name: Authorization
  code: |
    mock('getRequestBody', validBodyStr);

    /** *********************************************************/
    /** * Test 1 - Production auth token required but missing ***/
    /** *********************************************************/

    mock('getContainerVersion', { previewMode: false });
    runCode({
      useBearerToken: true,
      usePreviewBearerToken: false
    });
    assertApi('runContainer').wasNotCalled();


    /** ******************************************************/
    /** * Test 2 - Preview auth token required but missing ***/
    /** ******************************************************/

    mock('getContainerVersion', { previewMode: true });
    runCode({
      useBearerToken: true,
      usePreviewBearerToken: true
    });
    assertApi('runContainer').wasNotCalled();


    /** ***************************************************/
    /** * Test 3 - Does not claim unauthorized requests ***/
    /** ***************************************************/

    mock('getContainerVersion', { previewMode: false });
    runCode({
      rejectUnauthorized: false,
      useBearerToken: true,
      usePreviewBearerToken: true
    });
    assertApi('claimRequest').wasNotCalled();
    assertApi('runContainer').wasNotCalled();
    assertApi('setResponseStatus').wasNotCalledWith(401);


    /** ******************************************************/
    /** * Test 4 - Auth tokens not required for production ***/
    /** ******************************************************/

    mock('getContainerVersion', { previewMode: false });
    runCode({
      useBearerToken: false,
      usePreviewBearerToken: false
    });
    assertApi('runContainer').wasCalled(3);
    assertApi('claimRequest').wasCalled(1);


    /** **************************************************/
    /** * Test 5 - Auth tokens not required in preview ***/
    /** **************************************************/

    mock('getContainerVersion', { previewMode: true });
    runCode({
      useBearerToken: false,
      usePreviewBearerToken: false
    });
    assertApi('runContainer').wasCalled(6);
    assertApi('claimRequest').wasCalled(2);


    /** *********************************************/
    /** * Test 6 - Accepts valid production token ***/
    /** *********************************************/

    mock('getRequestHeader', 'Bearer prod-token');
    mock('getContainerVersion', { previewMode: false });
    runCode({
      useBearerToken: true,
      usePreviewBearerToken: false,
      bearerToken: 'prod-token'
    });
    assertApi('runContainer').wasCalled(9);
    assertApi('claimRequest').wasCalled(3);


    /** ******************************************/
    /** * Test 7 - Accepts valid preview token ***/
    /** ******************************************/

    mock('getRequestHeader', 'Bearer preview-token');
    mock('getContainerVersion', { previewMode: true });
    runCode({
      useBearerToken: false,
      usePreviewBearerToken: true,
      previewBearerToken: 'preview-token'
    });
    assertApi('runContainer').wasCalled(12);
    assertApi('claimRequest').wasCalled(4);
- name: Parse
  code: |
    /** *******************************************/
    /** * Test 1 - Fails when body is undefined ***/
    /** *******************************************/
    runCode();
    assertApi('runContainer').wasNotCalled();


    /** ******************************************/
    /** * Test 2 - Does not parse invalid JSON ***/
    /** ******************************************/
    mock('getRequestBody', invalidJsonStr);
    runCode();
    assertApi('runContainer').wasNotCalled();


    /** **************************************/
    /** *** Test 3 - Correctly Parses JSON ***/
    /** **************************************/
    mock('getRequestBody', validBodyStr);
    runCode();
    assertApi('runContainer').wasCalled();
- name: Process
  code: |
    // successfully processes all events
    mock('getRequestBody', validBodyStr);
    runCode();
    assertApi('runContainer').wasCalled(3);
- name: Schema
  code: "// number of type errors in this body is 1\nconst wrongTypeBody = {}; //\
    \ 1\n\n// number of type errors in this body is 1\nconst missingTypesEvent = [\n\
    \  {\n    'event_name': null, // 1\n  }\n];\n\n// number of type errors in this\
    \ event is 23\nconst wrongTypesEvent = [\n  {\n    client_id: 5, // 1\n    event_name:\
    \ true,  // 2\n    ip_override: 6,  // 3\n    language: false,  // 4\n    page_encoding:\
    \ {},  // 5\n    page_hostname: [],  // 6\n    page_location: 0.001,  // 7\n \
    \   page_path: 8,  // 8\n    page_referrer: false,  // 9\n    page_title: [],\
    \  // 10\n    screen_resolution: {},  // 11\n    user_agent: true,  // 12\n  \
    \  user_data: {\n      email_address: 4,  // 13\n      phone_number: false,  //\
    \ 14\n      first_name: [],  // 15\n      last_name: 10,  // 16\n      street:\
    \ 99,  // 17\n      city: {},  // 18\n      region: 1,  // 19\n      postal_code:\
    \ [],  // 20\n      country: true,  // 21\n    },\n    user_id: [],  // 22\n \
    \   viewport_size: false,  // 23\n  }\n];\n\nconst addedWrongTypesEvent = [\n\
    \  {\n    event_name: 'purchase',\n    test_string: true,\n    test_num: '4',\n\
    \    test_bool: 4,\n  }\n];\n\nconst addedTypes = {\n  \"categories\": {\n   \
    \ \"type\": \"array\",\n    \"required\": false,\n    \"value\": {\n      \"type\"\
    : \"string\",\n      \"required\": false\n    }\n  },\n  \"people\": {\n    \"\
    type\": \"array\",\n    \"required\": false,\n    \"value\": {\n      \"type\"\
    : \"object\",\n      \"required\": false,\n      \"value\": {\n        \"name\"\
    : { \"type\": \"string\", \"required\": false },\n        \"height\": { \"type\"\
    : \"string\", \"required\": false },\n        \"age\": { \"type\": \"number\"\
    , \"required\": false }\n      }\n    }\n  },\n  \"context\": {\n    \"type\"\
    : \"object\",\n    \"required\": false,\n    \"value\": {\n      \"locale\": {\
    \ \"type\": \"string\", \"required\": false }\n    }\n  }\n};\n\nconst addedTypesStr\
    \ = JSON.stringify(addedTypes);\n\n\n/** ************************************************************/\n\
    /** * Test 1 - All invalid fields in body log a schema error ***/\n/** ************************************************************/\n\
    \nmock('getRequestBody', JSON.stringify(wrongTypeBody));\nrunCode();\n// 1 invalid\
    \ body error\nassertApi('logToConsole').wasCalled(1);\nassertApi('runContainer').wasNotCalled();\n\
    \n\n/** ********************************************************************/\n\
    /** * Test 2 - All null/undefined fields in body log a missing error ***/\n/**\
    \ ********************************************************************/\n\nmock('getRequestBody',\
    \ JSON.stringify(missingTypesEvent));\nrunCode();\n// 3 = 1 missing but required\
    \ error + 1 invalid event error + 1 error from previous test\nassertApi('logToConsole').wasCalled(3);\n\
    assertApi('runContainer').wasNotCalled();\n\n\n/** *************************************************************/\n\
    /** * Test 3 - All invalid fields in event log a schema error ***/\n/** *************************************************************/\n\
    \nmock('getRequestBody', JSON.stringify(wrongTypesEvent));\nrunCode();\n// 27\
    \ = 23 type errors + 1 invalid event error + 3 errors from previous test\nassertApi('logToConsole').wasCalled(27);\n\
    assertApi('runContainer').wasNotCalled();\n\n\n/** *********************************************************/\n\
    /** * Test 4 - Added type check fields log require errors ***/\n/** *********************************************************/\n\
    \nmock('getRequestBody', JSON.stringify([validEventAllFields]));\nrunCode({\n\
    \  primitiveTypes: [\n    { field: 'test_string', type: 'string', required: true\
    \ },\n    { field: 'test_num', type: 'number', required: true },\n    { field:\
    \ 'test_bool', type: 'boolean', required: true }\n  ]\n});\n// 31 = 3 missing\
    \ but required errors + 1 invalid event error + 27 errors from previous test\n\
    assertApi('logToConsole').wasCalled(31);\nassertApi('runContainer').wasNotCalled();\n\
    \n\n/** ******************************************************/\n/** * Test 5\
    \ - Added type check fields log type errors ***/\n/** ******************************************************/\n\
    \nmock('getRequestBody', JSON.stringify(addedWrongTypesEvent));\nrunCode({\n \
    \ primitiveTypes: [\n    { field: 'test_string', type: 'string', required: false\
    \ },\n    { field: 'test_num', type: 'number', required: false },\n    { field:\
    \ 'test_bool', type: 'boolean', required: false }\n  ]\n});\n// 35 = 3 type errors\
    \ + 1 invalid event error + 31 errors from previous test\nassertApi('logToConsole').wasCalled(35);\n\
    assertApi('runContainer').wasNotCalled();\n\n\n/** ****************************************************************/\n\
    /** * Test 6 - Catches errors for added type array of primitives ***/\n/** ****************************************************************/\n\
    \nmock('getRequestBody', JSON.stringify([{\n  event_name: 'purhcase',\n  user_id:\
    \ '123',\n  categories: ['a', 1]\n}]));\nrunCode({ structuralTypes: addedTypesStr\
    \ });\n// 37 = 1 type errors + 1 invalid event error + 35 errors from previous\
    \ test\nassertApi('logToConsole').wasCalled(37);\nassertApi('runContainer').wasNotCalled();\n\
    \n\n/** *************************************************************/\n/** *\
    \ Test 7 - Catches errors for added type array of objects ***/\n/** *************************************************************/\n\
    \nmock('getRequestBody', JSON.stringify(\n  [{\n    event_name: 'purhcase',\n\
    \    user_id: '123',\n    people: [{\n      height: false,\n      age: \"string\"\
    \n    }]\n  }]\n));\nrunCode({ structuralTypes: addedTypesStr });\n// 40 = 2 type\
    \ errors + 1 invalid event error + 37 errors from previous test\nassertApi('logToConsole').wasCalled(40);\n\
    assertApi('runContainer').wasNotCalled();\n\n\n/** ***********************************************/\n\
    /** * Test 8 - Catches errors for added objects ***/\n/** ***********************************************/\n\
    \nmock('getRequestBody', JSON.stringify(\n  [{\n    event_name: 'purhcase',\n\
    \    user_id: '123',\n    context: { locale: 5 } \n  }]\n));\nrunCode({ structuralTypes:\
    \ addedTypesStr });\n// 42 = 1 type errors + 1 invalid event error + 40 errors\
    \ from previous test\nassertApi('logToConsole').wasCalled(42);\nassertApi('runContainer').wasNotCalled();\n\
    \n\n/** *************************************************/\n/** * Test 9 - Added\
    \ type check overrides default ***/\n/** *************************************************/\n\
    \nmock('getRequestBody', JSON.stringify(\n  [{ event_name: 'purchase', user_id:\
    \ 123 }]\n));\nrunCode({\n  primitiveTypes: [\n    { field: 'user_id', type: 'number',\
    \ required: false }\n  ]\n});\nassertApi('runContainer').wasCalled(1);\n\n\n/**\
    \ ******************************************************/\n/** * Test 10 - Added\
    \ required check overrides default ***/\n/** ******************************************************/\n\
    \nmock('getRequestBody', JSON.stringify([{ event_name: 'purchase', user_id: 123\
    \ }]));\nrunCode({\n  primitiveTypes: [\n    { field: 'user_id', type: 'number',\
    \ required: false }\n  ]\n});\nassertApi('runContainer').wasCalled(2);\n\n\n/**\
    \ *****************************************/\n/** * Test 11 - All events fit the\
    \ schema ***/\n/** *****************************************/\n\nmock('getRequestBody',\
    \ validBodyStr);\nrunCode();\nassertApi('runContainer').wasCalled(5);\n\n\n/**\
    \ ***************************************************************/\n/** * Test\
    \ 12 - Runs container when at least one event is valid ***/\n/** ***************************************************************/\n\
    mock('getRequestBody', oneEventInvalidStr);\nrunCode();\nassertApi('runContainer').wasCalled(6);\n"
- name: Status 200
  code: |
    /** ********************************/
    /** * Test 1 - No events in body ***/
    /** ********************************/

    mock('getRequestBody', '[]');
    runCode();
    assertApi('setResponseStatus').wasCalled(1);
    assertApi('returnResponse').wasCalled(1);
    assertApi('runContainer').wasNotCalled();


    /** ***********************************/
    /** * Test 2 - All events are valid ***/
    /** ***********************************/

    mock('getRequestBody', validBodyStr);
    runCode();
    // inside the callback to run Container is where we execute
    // setResponseStatus and returnResponse. We can't mock
    // runContainer, so just checking that it was called
    // is our verification that it was successful
    assertApi('runContainer').wasCalled(3);


    /** **************************************/
    /** * Additional Response Status Tests ***/
    /** **************************************/

    assertApi('setResponseStatus').wasCalledWith(200);
    assertApi('setResponseStatus').wasNotCalledWith(206);
    assertApi('setResponseStatus').wasNotCalledWith(400);
    assertApi('setResponseStatus').wasNotCalledWith(401);
    assertApi('setResponseStatus').wasNotCalledWith(422);
    assertApi('setResponseStatus').wasNotCalledWith(500);
- name: Status 206
  code: |
    // We are unable to mock a failing tag, so the only
    // 206 errors we can check for are a mix of valid
    // and invalid events

    // One event is valid, the other throws a schema error
    mock('getRequestBody', oneEventInvalidStr);
    runCode();
    // We can't mock runContainer, so setResponseStatus(206)
    // and returnResponse won't run. Our best method to see
    // if any messages worked at all is to test if runContainer
    // was called
    assertApi('runContainer').wasCalled(1);


    /** **************************************/
    /** * Additional Response Status Tests ***/
    /** **************************************/

    assertApi('setResponseStatus').wasNotCalledWith(200);
    // The commented out test below would pass if we could mock runContainer
    // assertApi('setResponseStatus').wasCalledWith(206);
    assertApi('setResponseStatus').wasNotCalledWith(400);
    assertApi('setResponseStatus').wasNotCalledWith(401);
    assertApi('setResponseStatus').wasNotCalledWith(422);
    assertApi('setResponseStatus').wasNotCalledWith(500);
- name: Status 400
  code: |
    // No body in request
    runCode();
    assertApi('setResponseStatus').wasCalled(1);
    assertApi('returnResponse').wasCalled(1);
    assertApi('runContainer').wasNotCalled();


    /** **************************************/
    /** * Additional Response Status Tests ***/
    /** **************************************/

    assertApi('setResponseStatus').wasNotCalledWith(200);
    assertApi('setResponseStatus').wasNotCalledWith(206);
    assertApi('setResponseStatus').wasCalledWith(400);
    assertApi('setResponseStatus').wasNotCalledWith(422);
    assertApi('setResponseStatus').wasNotCalledWith(500);
- name: Status 401
  code: |-
    // Return 401 error if rejectUnauthorized is checked
    mock('getRequestHeader', 'Bearer wrong-token');
    mock('getContainerVersion', { previewMode: false });
    runCode({
      rejectUnauthorized: true,
      useBearerToken: true,
      usePreviewBearerToken: true,
      bearerToken: 'right-token'
    });
    assertApi('runContainer').wasNotCalled();


    /** **************************************/
    /** * Additional Response Status Tests ***/
    /** **************************************/

    assertApi('setResponseStatus').wasNotCalledWith(200);
    assertApi('setResponseStatus').wasNotCalledWith(206);
    assertApi('setResponseStatus').wasNotCalledWith(400);
    assertApi('setResponseStatus').wasCalledWith(401);
    assertApi('setResponseStatus').wasNotCalledWith(422);
    assertApi('setResponseStatus').wasNotCalledWith(500);
- name: Status 422
  code: |
    const noValidEvents = [
      {},
      {
        'event_name': 5,
      }
    ];

    /** ***********************************************/
    /** * Test 1 - Request body does not fit schema ***/
    /** ***********************************************/

    mock('getRequestBody', JSON.stringify(validEventAllFields));
    runCode();
    assertApi('setResponseStatus').wasCalled(1);
    assertApi('returnResponse').wasCalled(1);
    assertApi('runContainer').wasNotCalled();


    /** ***********************************/
    /** * Test 2 - No events fit schema ***/
    /** ***********************************/

    mock('getRequestBody', JSON.stringify(noValidEvents));
    runCode();
    assertApi('setResponseStatus').wasCalled(2);
    assertApi('returnResponse').wasCalled(2);
    assertApi('runContainer').wasNotCalled();

    /** **********************************************/
    /** * Test 3 - Body in request is invalid JSON ***/
    /** **********************************************/

    mock('getRequestBody', invalidJsonStr);
    runCode();
    assertApi('setResponseStatus').wasCalled(3);
    assertApi('returnResponse').wasCalled(3);
    assertApi('runContainer').wasNotCalled();


    /** **************************************/
    /** * Additional Response Status Tests ***/
    /** **************************************/

    assertApi('setResponseStatus').wasNotCalledWith(200);
    assertApi('setResponseStatus').wasNotCalledWith(206);
    assertApi('setResponseStatus').wasNotCalledWith(400);
    assertApi('setResponseStatus').wasNotCalledWith(401);
    assertApi('setResponseStatus').wasCalledWith(422);
    assertApi('setResponseStatus').wasNotCalledWith(500);
setup: "const JSON = require('JSON');\n\nconst validEventAllFields = {\n  client_id:\
  \ 'ABC_123',\n  event_name: 'purchase',\n  ip_override: '1.2.3.4',\n  language:\
  \ 'en_us',\n  page_encoding: 'UTF-8',\n  page_hostname: 'example.com',\n  page_location:\
  \ 'https://example.com\t/us/en/',\n  page_path: '/path/to/page',\n  page_referrer:\
  \ 'https://www.google.com',\n  page_title: 'Home',\n  screen_resolution: '1024x768',\n\
  \  user_agent: 'Mozilla/5.0 . . .',\n  user_data: {\n    email_address: 'foo@example.com\t\
  ',\n    phone_number: '+15551234567',\n    first_name: 'Jane',\n    last_name: 'Doe',\n\
  \    street: '123 Fake St',\n    city: 'City Town',\n    region: 'CA',\n    postal_code:\
  \ '54321',\n    country: 'US',\n  },\n  user_id: 'ABC_123',\n  viewport_size: '725x345',\n\
  };\n\nconst oneEventInvalid = [\n  {\n    client_id: 'ABC_123',\n    event_name:\
  \ 'purchase',\n    ip_override: '1.2.3.4',\n    language: 'en_us',\n    page_encoding:\
  \ 'UTF-8',\n    page_hostname: 'example.com',\n    page_location: 'https://example.com\t\
  /us/en/',\n    page_path: '/path/to/page',\n    page_referrer: 'https://www.google.com',\n\
  \    page_title: 'Home',\n    screen_resolution: '1024x768',\n    user_agent: 'Mozilla/5.0\
  \ . . .',\n  },\n  {\n    client_id: 456,\n    event_name: 'purchase',\n  },\n];\n\
  \nconst oneEventInvalidStr = JSON.stringify(oneEventInvalid);\nconst invalidJsonStr\
  \ = '[{event_name: \"View Page\"';\nconst validBodyStr = JSON.stringify([validEventAllFields,\
  \ validEventAllFields, validEventAllFields]);\n"


___NOTES___

Copyright 2021 Square Inc.
 
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
 
    http://www.apache.org/licenses/LICENSE-2.0
 
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.


